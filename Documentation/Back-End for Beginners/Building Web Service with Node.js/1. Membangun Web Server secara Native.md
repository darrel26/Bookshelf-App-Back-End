## Create a new project

Untuk membuat sebuah *project* Node.js, bisa dengan menjalankan perintah, 

```powershell
npm init -y
```

Untuk saat ini struktur project akan berbentuk seperti ini,

```ruby
NODE-WEB-SERVER
|-- package.json
|-- server.js
```

## Membuat HTTP Server

Node.js menyediakan core modules http untuk membangun web server

```node
const http = require('http')
```

HTTP module memiliki banyak member seperti objek, properti, atau method yang berguna untuk melakukan hal-hal terkait protokol HTTP, salah satunya adalah method **http.createServer()**, yang berfungsi untuk membuat HTTP server. Method ini menerima satu parameter **custom callback** yang digunakan sebagai request listener, yang berisikan logika untuk menangani dan menanggapi sebuah *request*.  Dalam penulisannya **custom callback** tersebut menerima dua parameter yaitu ***request*** yang merupakan objeck yang menyimpan informasi terkait permintaan yang dikimkan oleh client, seperti alamat yang diminta, data yang dikirim, atau HTTP method yang digunakan dan ***response*** yang merupakan objek yang digunakan untuk menanggapi permintaan, melalui objek ini kita bisa menentukan data yang diberikan, format dokumen yang digunakan, kode status, atau informasi response lainnya.

```node
const requestListener = (request, response) => {
	response.setHeader('Content-Type', 'text/html');

	response.statusCode = 200;
	response.end('<h1>Halo HTTP Server!</h1>');
};
```

Agar server selalu sedia untuk menangani permintaan yang masuk, setiap instance dari **http.server** juga memiliki method **listen()** yang menerima 4 parameter, yaitu

- **port (number)** : jalur yang digunakan untuk mengakses HTTP server.
- **hostname (string)** : nama domain yang digunakan oleh HTTP server.
- **backlog (number)** : maksimal koneksi yang dapat ditunda (pending) pada HTTP server.
- **listeningListener (function)** : callback yang akan terpanggil ketika HTTP server sedang bekerja (listening).

Namun, keempat parameter di atas bersifat opsional. Kita bisa memberikan nilai port saja, atau kombinasi apa pun dari keempatnya.

```node
const port = 5000;
const host = 'localhost';

server.listen(port, host, () => {
	console.log(`Server berjalan pada http://${host}:${port}"`)
});
```

### Method/Verb Request

Fungsi request listener menyediakan dua parameter yakni **request** dan **response**. Fokus ke parameter request, parameter ini merupakan instance dari http.ClientRequest yang memiliki banyak properti di dalamnya. 

Melalui properti-propertinya ini kita dapat mengetahui seperti apa karakteristik dari permintaan HTTP yang dilakukan oleh client. Seperti method yang digunakan, path atau alamat yang dituju, data yang dikirimkan (bila ada), dan informasi lain mengenai permintaan tersebut.

Untuk mendapatkkan nilai **method** dari request, bisa dengan menggunakan properti **request.method**,

```node
const requestListener = (request, response) => {
	const method = request.method;
}
```

Properti **method** bernilai tipe method dalam bentuk string, yang dapat berupa GET, POST, PUT, atau method lainnya sesuai dengan yang client gunakan ketika melakukan **request**.

### Body Request

Ketika client melakukan **request** dengan method POST atau PUT, biasanya **request** tersebut memiliki sebuah data yang disimpan pada body request. Data tersebut dapat berupa format teks, JSON, berkas gambar, atau format lainnya. Data tersebut nantinya digunakan oleh server untuk diproses di database atau disimpan dalam bentuk objek utuh.

Ketahuilah bahwa http.clientRequest merupakan turunan dari readable stream, yang di mana untuk mendapatkan data body akan sedikit sulit dibandingkan dengan mendapatkan data header. Data di body didapatkan dengan teknik stream, seperti yang sudah kita ketahui, teknik ini memanfaatkan EventEmitter untuk mengirimkan bagian-bagian datanya. Dalam kasus http.clientRequest event **data** dan **end**-lah yang digunakan untuk mendapatkan data body.

```node
const requestListener = (request, response) => {
	let body = [];

	request.on('data', (chunk) => {
		body.push(chunk);
	});

	request.on('end', (chunk) => {
		body = Buffer.concat(body).toString();
	});
}
```

- **Pertama**, kita deklarasikan variabel body dan inisialisasikan nilainya dengan array kosong. Ini berfungsi untuk menampung buffer pada stream. 
- **Lalu**, ketika event data terjadi pada request, kita isi array body dengan chunk (potongan data) yang dibawa callback function pada event tersebut.
- **Terakhir**, ketika proses stream berakhir, maka event end akan terbangkitkan. Di sinilah kita mengubah variabel body yang sebelumnya menampung buffer menjadi data sebenarnya dalam bentuk string melalui perintah Buffer.concat(body).toString().

### Routing Request

Ketika menangani request, hal yang perlu dicek selain method adalah URL, contohnya ketika mengunjungi http://localhost:5000 dan http://localhost:5000/about akan menerima hasil yang berbeda dari server. Teknik ini dinamakan dengan routing. Routing merupakan istilah dalam menentukan respons server berdasarkan path atau url yang diminta oleh client.

Pada **http.clientRequest** untuk mendapatkan nilai URL bisa dengan cara,

```node
const requestListener = (request, response) => {
	const { url } = request;
};
```

Properti **url** akan mengembalikan nilai path secara lengkap tanpa **host** dan **port** yang digunakan server. Jika client melakukan **request** terhadap alamat http://localhost:5000/about atau http://localhost:5000/about/, maka url akan bernilai **'/about'**; dan bila melakukan **request** pada alamat http://localhost:5000 atau http://localhost:5000/ maka url akan bernilai **'/'**.

### Response Status

Response status merupakan salah satu bagian dari respons yang berisikan tentang informasi apakah sebuah request berhasil atau gagal dilakukan. Status yang diberikan berupa kode (status code) dan pesan dari kode tersebut dalam bentuk teks (status message).

Indikasi keberhasilan request client ditentukan oleh response status code yang dikirim oleh server. Karena itu, tentu nilai status code tak bisa sembarang kita tetapkan. Status code haruslah bernilai 3 digit angka dengan ketentuan berikut:

- 100-199 : informational responses.
- **200 - 299 : successful responses.**
- 300-399 : redirect.
- **400-499 : client error.**
- **500-599 : server errors.**

[HTTP Status - MDN](https://developer.mozilla.org/id/docs/Web/HTTP/Status).

Pada Node.js penetapan nilai status code pada response dilakukan melalui properti **response.statusCode**

>   Status Code selalu diiringi dengan status message. Contoh **200 Ok**, **400 Bad Request**, dan **404 Not Found**. Melalui status message ini kita dan juga client bisa paham maksud dari status kode.

Status message memiliki nilai standar sesuai dengan response code. Namun, kita bisa mengubahnya bila diperlukan. Untuk mengubah status message, bisa diakses melalui properti **response.statusMessage**.

### Response Header

Pada url [http://localhost:5000](http://localhost:5000/) server akan mengembalikan pesan “Ini adalah homepage” atau pada url [http://localhost:5000/about](http://localhost:5000/about) server akan mengembalikan pesan “Halo! Ini adalah halaman about”. Pesan yang ditampilkan tampak besar dan tebal karena ia dibungkus oleh elemen heading HTML.

Server bisa merespons dengan memberikan data dalam tipe (MIME types) lain, seperti XML, JSON, gambar, atau sekadar teks biasa. Apa pun MIME types yang digunakan, web server wajib memberi tahu pada client. 

Caranya, lampirkan property ‘**Content-Type**’ dengan nilai MIME types yang disisipkan pada header response. Untuk menyisipkan nilai pada header response, gunakanlah method **setHeader()** yang menerima 2 parameter yaitu nama properti, dan nilai untuk header-nya.

```node
response.setHeader('Content-Type', 'application/json')
```

>  Penulisan properti header dituliskan secara ***Proper Case*** atau setiap kata diawali dengan huruf kapital dan setiap katanya dipisahkan oleh tanda garis (-).

### Response Body

Selain header, HTTP respons juga membawa body (Anda mengetahui ini pada materi pola [komunikasi client dan server](https://www.dicoding.com/academies/261/tutorials/14147/)). Di dalam body inilah data utama (atau bisa kita sebut konten) seharusnya disimpan.

Objek response yang berada pada parameter fungsi request listener adalah instance dari **http.serverResponse**. Di mana ia merupakan **WritableStream**. Seperti objek **WritableStream** lainnya, untuk menuliskan data pada respons kita bisa gunakan method **response.write()** dan diakhiri dengan method **response.end()**.

```node
const requestListener = (request, response) => {
	response.write('<html>');
	response.write('<body>');
	response.write('<h1>Hello, World!</h1>');
	response.write('</body>');
	response.write('</html>');
	response.end();
};
```

Method **end()** pada **WritableStream** dapat digunakan untuk menulis data terakhir sebelum proses penulisan diakhiri. Jadi, untuk kasus di atas dapat dipersingkat penulisannya menjadi seperti ini.

```node
const requestListener = (request, response) => {
	response.end('<html><body><h1>Hello, World!</h1></body></html>');
};
```

>   Penting untuk menuliskan **status** dan **header** response sebelum menuliskan data pada body. Karena tidak masuk akal bila Anda sudah menuliskan body, namun belum memberikan metadata terkait data apa yang hendak dikirim.

